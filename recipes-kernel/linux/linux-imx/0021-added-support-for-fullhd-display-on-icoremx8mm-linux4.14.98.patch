From 53b4dbb39857a4e4307210bfd9b87dbc2a4b52d4 Mon Sep 17 00:00:00 2001
From: Domenico <domenico.acri@engicam.com>
Date: Thu, 6 Jun 2019 09:37:27 +0200
Subject: [PATCH 1/1] added support for fullhd display on icoremx8mm

---
 arch/arm64/boot/dts/engicam/icore-imx8mm.dts     |  42 ++++-
 drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_brg.c | 192 +++++++++++++++--------
 drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_brg.h |   7 +-
 drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_drv.c |  30 +++-
 4 files changed, 190 insertions(+), 81 deletions(-)

diff --git a/arch/arm64/boot/dts/engicam/icore-imx8mm.dts b/arch/arm64/boot/dts/engicam/icore-imx8mm.dts
index 86d068a..2e144fe 100644
--- a/arch/arm64/boot/dts/engicam/icore-imx8mm.dts
+++ b/arch/arm64/boot/dts/engicam/icore-imx8mm.dts
@@ -18,7 +18,7 @@
 #include "../freescale/fsl-imx8mm.dtsi"
 #include "icore-imx8mm-sgtl5000.dtsi"
 #include "icore-imx8mm-laird.dtsi"
-
+//#define FULL_HD_PANEL
 / {
 	model = "Engicam i.Core MX8MM module";
 	compatible = "engi,icore-imx8mm", "fsl,imx8mm-evk", "fsl,imx8mm";
@@ -684,26 +684,56 @@
     lvds_bridge: sn65dsi83@2c {
         compatible = "ti,sn65dsi83";
         reg = <0x2c>;
+#ifdef FULL_HD_PANEL
+        ti,dsi-lanes = <4>;
+        ti,lvds-format = <1>;
+        ti,lvds-bpp = <24>;
+        ti,width-mm = <149>;
+        ti,height-mm = <93>;
+		ti,dual-channels = <1>;
+//		ti,pattern = <1>;
+#else
         ti,dsi-lanes = <2>;
         ti,lvds-format = <2>;
         ti,lvds-bpp = <24>;
         ti,width-mm = <149>;
         ti,height-mm = <93>;
+//		ti,pattern = <1>;
+#endif
 		enable-gpios = <&gpio3 9  GPIO_ACTIVE_HIGH>;
         pinctrl-names = "default";
         pinctrl-0 = <&pinctrl_dsi_lvds_bridge>;
         status = "okay";
 
+#ifdef FULL_HD_PANEL
+       display-timings { 
+            lvds {
+                clock-frequency = <165000000>;
+                hactive = <1920>;
+                vactive = <1080>;
+                hback-porch = <32>;
+                hfront-porch = <32>;
+                vback-porch = <17>;
+                vfront-porch = <16>;
+                hsync-len = <32>;
+                vsync-len = <17>;
+                hsync-active = <0>;
+                vsync-active = <0>;
+                de-active = <1>;
+                pixelclk-active = <0>;
+            };
+        };
+#else
        display-timings {
             lvds {
                 clock-frequency = <62500000>;
                 hactive = <1024>;
                 vactive = <600>;
-                hback-porch = <6>;
-                hfront-porch = <5>;
+                hback-porch = <60>;
+                hfront-porch = <50>;
                 vback-porch = <2>;
                 vfront-porch = <3>;
-                hsync-len = <2>;
+                hsync-len = <20>;
                 vsync-len = <1>;
                 hsync-active = <0>;
                 vsync-active = <0>;
@@ -711,7 +741,7 @@
                 pixelclk-active = <0>;
             };
         };
-
+#endif
         port {
             sn65dsi83_in: endpoint {
                 remote-endpoint = <&dsim_to_sn65dsi8>;
@@ -722,7 +752,7 @@
 };
 
 &lcdif {
-	max-res = <1280>, <800>;
+	max-res = <1920>, <1200>;
 	status = "okay";
 };
 
diff --git a/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_brg.c b/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_brg.c
index 99568f0..7cda84f 100644
--- a/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_brg.c
+++ b/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_brg.c
@@ -11,7 +11,7 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  */
-
+//#define DEBUG
 #include <linux/i2c.h>
 #include <linux/device.h>
 #include <linux/gpio/consumer.h>
@@ -46,6 +46,7 @@
 #define SN65DSI83_PLL_EN             0x0D
 #define SN65DSI83_DSI_CFG            0x10
     #define CHA_DSI_LANES_SHIFT    3
+    #define CHB_DSI_LANES_SHIFT    1
 
 #define SN65DSI83_DSI_EQ              0x11
 #define SN65DSI83_CHA_DSI_CLK_RNG     0x12
@@ -56,7 +57,9 @@
     #define VS_NEG_POLARITY_SHIFT 5
     #define LVDS_LINK_CFG_SHIFT   4
     #define CHA_24BPP_MODE_SHIFT  3
+    #define CHB_24BPP_MODE_SHIFT  2
     #define CHA_24BPP_FMT1_SHIFT  1
+    #define CHB_24BPP_FMT1_SHIFT  0
 
 #define SN65DSI83_LVDS_SIGN           0x19
 #define SN65DSI83_LVDS_TERM           0x1A
@@ -96,7 +99,7 @@
 
 static int sn65dsi83_brg_power_on(struct sn65dsi83_brg *brg)
 {
-    dev_info(&brg->client->dev,"%s\n",__func__);
+    dev_dbg(&brg->client->dev,"%s\n",__func__);
     gpiod_set_value_cansleep(brg->gpio_enable, 1);
     /* Wait for 1ms for the internal voltage regulator to stabilize */
     msleep(1);
@@ -106,7 +109,7 @@ static int sn65dsi83_brg_power_on(struct sn65dsi83_brg *brg)
 
 static void sn65dsi83_brg_power_off(struct sn65dsi83_brg *brg)
 {
-    dev_info(&brg->client->dev,"%s\n",__func__);
+    dev_dbg(&brg->client->dev,"%s\n",__func__);
     gpiod_set_value_cansleep(brg->gpio_enable, 0);
     /*
      * The EN pin must be held low for at least 10 ms
@@ -124,8 +127,6 @@ static int sn65dsi83_write(struct i2c_client *client, u8 reg, u8 val)
     if (ret)
         dev_err(&client->dev, "failed to write at 0x%02x", reg);
 
-    dev_dbg(&client->dev, "%s: write reg 0x%02x data 0x%02x", __func__, reg, val);
-
     return ret;
 }
 #define SN65DSI83_WRITE(reg,val) sn65dsi83_write(client, (reg) , (val))
@@ -134,7 +135,6 @@ static int sn65dsi83_read(struct i2c_client *client, u8 reg)
 {
     int ret;
 
-    dev_info(&client->dev, "client 0x%p", client);
     ret = i2c_smbus_read_byte_data(client, reg);
 
     if (ret < 0) {
@@ -142,48 +142,54 @@ static int sn65dsi83_read(struct i2c_client *client, u8 reg)
         return ret;
     }
 
-    dev_dbg(&client->dev, "%s: read reg 0x%02x data 0x%02x", __func__, reg, ret);
-
     return ret;
 }
 #define SN65DSI83_READ(reg) sn65dsi83_read(client, (reg))
 
-static int sn65dsi83_brg_start_stream(struct sn65dsi83_brg *brg)
+void sn65dsi83_print_error(struct sn65dsi83_brg *brg)
 {
     int regval;
     struct i2c_client *client = I2C_CLIENT(brg);
 
-    dev_info(&client->dev,"%s\n",__func__);
-    /* Set the PLL_EN bit (CSR 0x0D.0) */
-    SN65DSI83_WRITE(SN65DSI83_PLL_EN, 0x1);
-    /* Wait for the PLL_LOCK bit to be set (CSR 0x0A.7) */
-    msleep(200);
-
-    /* Perform SW reset to apply changes */
-    SN65DSI83_WRITE(SN65DSI83_SOFT_RESET, 0x01);
-
-    /* Read CHA Error register */
     regval = SN65DSI83_READ(SN65DSI83_CHA_ERR);
-    dev_info(&client->dev, "CHA (0x%02x) = 0x%02x",
+    dev_dbg(&client->dev, "CHA (0x%02x) = 0x%02x",
          SN65DSI83_CHA_ERR, regval);
 
 	SN65DSI83_WRITE(SN65DSI83_CHA_ERR, 0xff);
     regval = SN65DSI83_READ(SN65DSI83_CHA_ERR);
-    dev_info(&client->dev, "CHA (0x%02x) = 0x%02x",
+    dev_dbg(&client->dev, "CHA (0x%02x) = 0x%02x",
          SN65DSI83_CHA_ERR, regval);
     msleep(10);
 
     regval = SN65DSI83_READ(SN65DSI83_CHA_ERR);
-    dev_info(&client->dev, "CHA (0x%02x) = 0x%02x",
+    dev_dbg(&client->dev, "CHA (0x%02x) = 0x%02x",
          SN65DSI83_CHA_ERR, regval);
 
+}
+
+static int sn65dsi83_brg_start_stream(struct sn65dsi83_brg *brg)
+{
+    struct i2c_client *client = I2C_CLIENT(brg);
+
+    dev_dbg(&client->dev,"%s\n",__func__);
+    /* Set the PLL_EN bit (CSR 0x0D.0) */
+    SN65DSI83_WRITE(SN65DSI83_PLL_EN, 0x1);
+    /* Wait for the PLL_LOCK bit to be set (CSR 0x0A.7) */
+    msleep(200);
+
+    /* Perform SW reset to apply changes */
+    SN65DSI83_WRITE(SN65DSI83_SOFT_RESET, 0x01);
+
+    /* Read CHA Error register */
+	sn65dsi83_print_error(brg);
+
     return 0;
 }
 
 static void sn65dsi83_brg_stop_stream(struct sn65dsi83_brg *brg)
 {
     struct i2c_client *client = I2C_CLIENT(brg);
-    dev_info(&client->dev,"%s\n",__func__);
+    dev_dbg(&client->dev,"%s\n",__func__);
     /* Clear the PLL_EN bit (CSR 0x0D.0) */
     SN65DSI83_WRITE(SN65DSI83_PLL_EN, 0x00);
 }
@@ -231,12 +237,17 @@ static int sn65dsi83_calk_div(int min_regval, int max_regval, int min_div,
 
 static int sn65dsi83_brg_configure(struct sn65dsi83_brg *brg)
 {
-    int regval = 0;
+    int regval = 0, i;
     struct i2c_client *client = I2C_CLIENT(brg);
     struct videomode *vm = VM(brg);
+	unsigned long pixelclock;	/* pixelclock in Hz */
 
     u32 dsi_clk = (((PIXCLK * BPP(brg)) / DSI_LANES(brg)) >> 1);
 
+	pixelclock = PIXCLK;
+    if (DUAL_CHANNELS(brg) != 0)
+		pixelclock /= 2;
+    dev_info(&client->dev, "PIXCLK [ %ld ] Hz\n",pixelclock);
     dev_info(&client->dev, "DSI clock [ %u ] Hz\n",dsi_clk);
     dev_info(&client->dev, "GeoMetry [ %d x %d ] Hz\n",HACTIVE,VACTIVE);
 
@@ -245,17 +256,19 @@ static int sn65dsi83_brg_configure(struct sn65dsi83_brg *brg)
     SN65DSI83_WRITE(SN65DSI83_PLL_EN,0x00);
 
     /* LVDS clock setup */
-    if  ((25000000 <= PIXCLK) && (PIXCLK < 37500000))
+    if  ((25000000 <= pixelclock) && (pixelclock < 37500000))
         regval = 0;
     else
         regval = sn65dsi83_calk_clk_range(0x01, 0x05, 37500000, 25000000,
-                    PIXCLK);
+                    pixelclock);
 
     if (regval < 0) {
         dev_err(&client->dev, "failed to configure LVDS clock");
         return -EINVAL;
     }
 
+    dev_dbg(&client->dev, "LVDS_CLK_RANGE_SHIFT [ 0x%x ] \n",regval);
+
     regval = (regval << LVDS_CLK_RANGE_SHIFT);
     regval |= (1 << HS_CLK_SRC_SHIFT); /* Use DSI clock */
     SN65DSI83_WRITE(SN65DSI83_CORE_PLL,regval);
@@ -266,23 +279,28 @@ static int sn65dsi83_brg_configure(struct sn65dsi83_brg *brg)
         dev_err(&client->dev, "failed to configure DSI clock range\n");
         return -EINVAL;
     }
+    dev_dbg(&client->dev, "SN65DSI83_CHA_DSI_CLK_RNG [ 0x%x ] \n",regval);
     SN65DSI83_WRITE(SN65DSI83_CHA_DSI_CLK_RNG,regval);
 
     /* DSI clock divider */
-    regval = sn65dsi83_calk_div(0x0, 0x18, 1, 1, dsi_clk, PIXCLK);
+    regval = sn65dsi83_calk_div(0x0, 0x18, 1, 1, dsi_clk, pixelclock);
     if (regval < 0) {
         dev_err(&client->dev, "failed to calculate DSI clock divider");
         return -EINVAL;
     }
-
+	
+    dev_dbg(&client->dev, "SN65DSI83_PLL_DIV (divider) [ 0x%x ] \n",regval);
     regval = regval << DSI_CLK_DIV_SHIFT;
+    dev_dbg(&client->dev, "SN65DSI83_PLL_DIV (regval) [ 0x%x ] \n",regval);
     SN65DSI83_WRITE(SN65DSI83_PLL_DIV,regval);
 
     /* Configure DSI_LANES  */
-    regval = SN65DSI83_READ(SN65DSI83_DSI_CFG);
+	regval =  SN65DSI83_READ(SN65DSI83_DSI_CFG);
     regval &= ~(3 << CHA_DSI_LANES_SHIFT);
+    regval &= ~(3 << CHB_DSI_LANES_SHIFT);
     regval |= ((4 - DSI_LANES(brg)) << CHA_DSI_LANES_SHIFT);
-	printk("DSI lanes = %d.... val = 0x%x\n", (int)DSI_LANES(brg), regval);
+    regval |= ((4 - DSI_LANES(brg)) << CHB_DSI_LANES_SHIFT);
+	dev_dbg(&client->dev, "DSI lanes = %d.... val = 0x%x\n", (int)DSI_LANES(brg), regval);
     SN65DSI83_WRITE(SN65DSI83_DSI_CFG,regval);
 
     /* CHA_DSI_DATA_EQ - No Equalization */
@@ -290,7 +308,7 @@ static int sn65dsi83_brg_configure(struct sn65dsi83_brg *brg)
     SN65DSI83_WRITE(SN65DSI83_DSI_EQ,0x00);
 
     /* Video formats */
-    regval = 0;
+    regval = 0x0;
     if (FLAGS & DISPLAY_FLAGS_HSYNC_LOW)
         regval |= (1 << HS_NEG_POLARITY_SHIFT);
 
@@ -298,17 +316,32 @@ static int sn65dsi83_brg_configure(struct sn65dsi83_brg *brg)
         regval |= (1 << VS_NEG_POLARITY_SHIFT);
 
     if (BPP(brg) == 24)
+	{
         regval |= (1 << CHA_24BPP_MODE_SHIFT);
+        regval |= (1 << CHB_24BPP_MODE_SHIFT);
+	}
 
     if (FORMAT(brg) == 1)
+	{
         regval |= (1 << CHA_24BPP_FMT1_SHIFT);
-
-    regval |= (1 << LVDS_LINK_CFG_SHIFT);
-	printk("SN65DSI83_LVDS_MODE = 0x%x\n", regval);
+        regval |= (1 << CHB_24BPP_FMT1_SHIFT);
+	}
+
+    if (DUAL_CHANNELS(brg) != 0)
+	{
+	    dev_info(&client->dev, "LVDS DUAL CHANNELS\n");
+	    regval |= (0 << LVDS_LINK_CFG_SHIFT); // DUAL CHANNELS
+	}
+	else
+	{
+	    dev_info(&client->dev, "LVDS SINGLE CHANNEL\n");
+	    regval |= (1 << LVDS_LINK_CFG_SHIFT); // SINGLE CHANNEL
+	}
+	dev_dbg(&client->dev, "SN65DSI83_LVDS_MODE = 0x%x\n", regval);
     SN65DSI83_WRITE(SN65DSI83_LVDS_MODE,regval);
 
     /* Voltage and pins */
-    SN65DSI83_WRITE(SN65DSI83_LVDS_SIGN,0x00);
+    SN65DSI83_WRITE(SN65DSI83_LVDS_SIGN,0x05);
     SN65DSI83_WRITE(SN65DSI83_LVDS_TERM,0x03);
     SN65DSI83_WRITE(SN65DSI83_LVDS_CM_ADJ,0x00);
 
@@ -316,45 +349,68 @@ static int sn65dsi83_brg_configure(struct sn65dsi83_brg *brg)
     SN65DSI83_WRITE(SN65DSI83_CHA_SYNC_DELAY_LO,0x21);
     SN65DSI83_WRITE(SN65DSI83_CHA_SYNC_DELAY_HI,0x00);
 
-    /* Geometry */
-    SN65DSI83_WRITE(SN65DSI83_CHA_LINE_LEN_LO,LOW(HACTIVE));
-    SN65DSI83_WRITE(SN65DSI83_CHA_LINE_LEN_HI,HIGH(HACTIVE));
-
-    SN65DSI83_WRITE(SN65DSI83_CHA_VERT_LINES_LO,LOW(VACTIVE));
-    SN65DSI83_WRITE(SN65DSI83_CHA_VERT_LINES_HI,HIGH(VACTIVE));
+    /* Geometry CHA */
+    if ((PATTERN(brg) != 0) && (DUAL_CHANNELS(brg) != 0))
+	{
+		SN65DSI83_WRITE(SN65DSI83_CHA_LINE_LEN_LO,LOW(HACTIVE/2));
+		SN65DSI83_WRITE(SN65DSI83_CHA_LINE_LEN_HI,HIGH(HACTIVE/2));
+	}
+	else
+	{
+		SN65DSI83_WRITE(SN65DSI83_CHA_LINE_LEN_LO,LOW(HACTIVE));
+		SN65DSI83_WRITE(SN65DSI83_CHA_LINE_LEN_HI,HIGH(HACTIVE));
+	}
 
     SN65DSI83_WRITE(SN65DSI83_CHA_HSYNC_WIDTH_LO,LOW(HPW));
     SN65DSI83_WRITE(SN65DSI83_CHA_HSYNC_WIDTH_HI,HIGH(HPW));
 
-    SN65DSI83_WRITE(SN65DSI83_CHA_VSYNC_WIDTH_LO,LOW(VPW));
-    SN65DSI83_WRITE(SN65DSI83_CHA_VSYNC_WIDTH_HI,HIGH(VPW));
-
     SN65DSI83_WRITE(SN65DSI83_CHA_HORZ_BACKPORCH,LOW(HBP));
-    SN65DSI83_WRITE(SN65DSI83_CHA_VERT_BACKPORCH,LOW(VBP));
-
     SN65DSI83_WRITE(SN65DSI83_CHA_HORZ_FRONTPORCH,LOW(HFP));
-    SN65DSI83_WRITE(SN65DSI83_CHA_VERT_FRONTPORCH,LOW(VFP));
-
-    SN65DSI83_WRITE(SN65DSI83_TEST_PATTERN,0x00);
-    SN65DSI83_WRITE(SN65DSI83_REG_3D,0x00);
-    SN65DSI83_WRITE(SN65DSI83_REG_3E,0x00);
-
-    /* mute channel B */
-    SN65DSI83_WRITE(SN65DSI83_CHB_DSI_CLK_RNG, 0x00);
-    SN65DSI83_WRITE(SN65DSI83_CHB_LINE_LEN_LO, 0x00);
-    SN65DSI83_WRITE(SN65DSI83_CHB_LINE_LEN_HI, 0x00);
-    SN65DSI83_WRITE(SN65DSI83_CHB_VERT_LINES_LO, 0x00);
-    SN65DSI83_WRITE(SN65DSI83_CHB_VERT_LINES_HI, 0x00);
-    SN65DSI83_WRITE(SN65DSI83_CHB_SYNC_DELAY_LO, 0x00);
-    SN65DSI83_WRITE(SN65DSI83_CHB_SYNC_DELAY_HI, 0x00);
-    SN65DSI83_WRITE(SN65DSI83_CHB_HSYNC_WIDTH_LO, 0x00);
-    SN65DSI83_WRITE(SN65DSI83_CHB_HSYNC_WIDTH_HI, 0x00);
-    SN65DSI83_WRITE(SN65DSI83_CHB_VSYNC_WIDTH_LO, 0x00);
-    SN65DSI83_WRITE(SN65DSI83_CHB_VSYNC_WIDTH_HI, 0x00);
-    SN65DSI83_WRITE(SN65DSI83_CHB_HORZ_BACKPORCH, 0x00);
-    SN65DSI83_WRITE(SN65DSI83_CHB_VERT_BACKPORCH, 0x00);
-    SN65DSI83_WRITE(SN65DSI83_CHB_HORZ_FRONTPORCH, 0x00);
-    SN65DSI83_WRITE(SN65DSI83_CHB_VERT_FRONTPORCH, 0x00);
+
+	SN65DSI83_WRITE(SN65DSI83_CHA_VSYNC_WIDTH_LO, LOW(VPW));
+	SN65DSI83_WRITE(SN65DSI83_CHA_VSYNC_WIDTH_HI, HIGH(VPW));
+
+	/* mute channel B */
+	SN65DSI83_WRITE(SN65DSI83_CHB_DSI_CLK_RNG, 0x00);
+	SN65DSI83_WRITE(SN65DSI83_CHB_LINE_LEN_LO, 0x00);
+	SN65DSI83_WRITE(SN65DSI83_CHB_LINE_LEN_HI, 0x00);
+	SN65DSI83_WRITE(SN65DSI83_CHB_VERT_LINES_LO, 0x00);
+	SN65DSI83_WRITE(SN65DSI83_CHB_VERT_LINES_HI, 0x00);
+	SN65DSI83_WRITE(SN65DSI83_CHB_SYNC_DELAY_LO, 0x00);
+	SN65DSI83_WRITE(SN65DSI83_CHB_SYNC_DELAY_HI, 0x00);
+	SN65DSI83_WRITE(SN65DSI83_CHB_HSYNC_WIDTH_LO, 0x00);
+	SN65DSI83_WRITE(SN65DSI83_CHB_HSYNC_WIDTH_HI, 0x00);
+	SN65DSI83_WRITE(SN65DSI83_CHB_VSYNC_WIDTH_LO, 0x00);
+	SN65DSI83_WRITE(SN65DSI83_CHB_VSYNC_WIDTH_HI, 0x00);
+	SN65DSI83_WRITE(SN65DSI83_CHB_HORZ_BACKPORCH, 0x00);
+	SN65DSI83_WRITE(SN65DSI83_CHB_VERT_BACKPORCH, 0x00);
+	SN65DSI83_WRITE(SN65DSI83_CHB_HORZ_FRONTPORCH, 0x00);
+	SN65DSI83_WRITE(SN65DSI83_CHB_VERT_FRONTPORCH, 0x00);
+
+	if(PATTERN(brg) != 0)
+	{
+		SN65DSI83_WRITE(SN65DSI83_TEST_PATTERN, 1<<4);
+		SN65DSI83_WRITE(SN65DSI83_CHA_VERT_LINES_LO, LOW(VACTIVE));
+		SN65DSI83_WRITE(SN65DSI83_CHA_VERT_LINES_HI, HIGH(VACTIVE));
+	    SN65DSI83_WRITE(SN65DSI83_CHA_VERT_BACKPORCH, LOW(VBP));
+	    SN65DSI83_WRITE(SN65DSI83_CHA_VERT_FRONTPORCH,LOW(VFP));
+	}
+	else
+	{
+		SN65DSI83_WRITE(SN65DSI83_TEST_PATTERN, 0<<4);
+		SN65DSI83_WRITE(SN65DSI83_CHA_VERT_LINES_LO, 0x00);
+		SN65DSI83_WRITE(SN65DSI83_CHA_VERT_LINES_HI, 0x00);
+	    SN65DSI83_WRITE(SN65DSI83_CHA_VERT_BACKPORCH, 0x00);
+	    SN65DSI83_WRITE(SN65DSI83_CHA_VERT_FRONTPORCH, 0x00);
+	}
+	SN65DSI83_WRITE(SN65DSI83_REG_3D,0x00);
+	SN65DSI83_WRITE(SN65DSI83_REG_3E,0x00);
+
+	for (i=0x09; i<=0x3e; i++)
+	{
+		regval =  SN65DSI83_READ(i);
+		dev_dbg(&client->dev, "addr=0x%x regval=0x%x \n", i, regval);
+	}
     return 0;
 }
 
diff --git a/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_brg.h b/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_brg.h
index 9f23df8..fe079dc 100644
--- a/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_brg.h
+++ b/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_brg.h
@@ -24,8 +24,11 @@ struct sn65dsi83_brg {
     u32 height_mm;
     u32 format;
     u32 bpp;
-
+	u32 dual_channels;
+	u32 pattern;
+	
     u8 num_dsi_lanes;
+	
     struct sn65dsi83_brg_funcs *funcs;
 };
 struct sn65dsi83_brg *sn65dsi83_brg_get(void);
@@ -34,6 +37,8 @@ struct sn65dsi83_brg *sn65dsi83_brg_get(void);
 #define I2C_CLIENT(A) (A)->client
 #define VM(A) &(A)->vm
 #define BPP(A) (A)->bpp
+#define DUAL_CHANNELS(A) (A)->dual_channels
+#define PATTERN(A) (A)->pattern
 #define FORMAT(A) (A)->format
 #define DSI_LANES(A) (A)->num_dsi_lanes
 
diff --git a/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_drv.c b/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_drv.c
index 50ff50d..f765281 100644
--- a/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_drv.c
+++ b/drivers/gpu/drm/bridge/sn65dsi83/sn65dsi83_drv.c
@@ -1,7 +1,7 @@
 /*
  * Licensed under the GPL-2.
  */
-
+//#define DEBUG
 #include <linux/device.h>
 #include <linux/gpio/consumer.h>
 #include <linux/module.h>
@@ -73,9 +73,15 @@ static int sn65dsi83_connector_get_modes(struct drm_connector *connector)
     connector->display_info.height_mm = mode->height_mm;
 
     if (brg->vm.flags & DISPLAY_FLAGS_DE_HIGH)
+	{
+	    dev_dbg(dev, "%s DISPLAY_FLAGS_DE_HIGH\n",__func__);
         *bus_flags |= DRM_BUS_FLAG_DE_HIGH;
-    if (brg->vm.flags & DISPLAY_FLAGS_DE_LOW)
+	}
+    if (brg->vm.flags & DISPLAY_FLAGS_DE_LOW)	
+	{
+	    dev_dbg(dev, "%s DISPLAY_FLAGS_DE_HIGH\n",__func__);
         *bus_flags |= DRM_BUS_FLAG_DE_LOW;
+	}
     if (brg->vm.flags & DISPLAY_FLAGS_PIXDATA_NEGEDGE)
         *bus_flags |= DRM_BUS_FLAG_PIXDATA_NEGEDGE;
     if (brg->vm.flags & DISPLAY_FLAGS_PIXDATA_POSEDGE)
@@ -89,6 +95,8 @@ static int sn65dsi83_connector_get_modes(struct drm_connector *connector)
     return 1;
 }
 
+void sn65dsi83_print_error(struct sn65dsi83_brg *brg);
+
 static enum drm_mode_status
 sn65dsi83_connector_mode_valid(struct drm_connector *connector,
                  struct drm_display_mode *mode)
@@ -96,11 +104,16 @@ sn65dsi83_connector_mode_valid(struct drm_connector *connector,
     struct sn65dsi83 *sn65dsi83 = connector_to_sn65dsi83(connector);
     struct device *dev = connector->dev->dev;
 	if (mode->clock > ( sn65dsi83->brg->vm.pixelclock / 1000 ))
+	{	
+	    dev_err(dev, "%s: wrong mode clock\n",__func__);
 		return MODE_CLOCK_HIGH;
-
-    dev_info(dev, "%s: mode: %d*%d@%d is valid\n",__func__,
+	}
+    
+	dev_info(dev, "%s: mode: %d*%d@%d is valid\n",__func__,
             mode->hdisplay,mode->vdisplay,mode->clock);
 
+	sn65dsi83_print_error(sn65dsi83->brg);
+	
 	//drm_kms_helper_hotplug_event(connector->dev);
     return MODE_OK;
 }
@@ -215,7 +228,7 @@ static int sn65dsi83_parse_dt(struct device_node *np,
     struct sn65dsi83 *sn65dsi83)
 {
     struct device *dev = &sn65dsi83->brg->client->dev;
-    u32 num_lanes = 4, bpp = 24, format = 2, width = 149, height = 93;
+    u32 num_lanes = 4, bpp = 24, format = 2, width = 149, height = 93, dual_channels = 0, pattern = 0;
     struct device_node *endpoint;
 
 	dev_dbg(dev, "sn65dsi83_parse_dt\n");
@@ -236,6 +249,8 @@ static int sn65dsi83_parse_dt(struct device_node *np,
     of_property_read_u32(np, "ti,lvds-bpp", &bpp);
     of_property_read_u32(np, "ti,width-mm", &width);
     of_property_read_u32(np, "ti,height-mm", &height);
+    of_property_read_u32(np, "ti,dual-channels", &dual_channels);
+    of_property_read_u32(np, "ti,pattern", &pattern);
 
     if (num_lanes < 1 || num_lanes > 4) {
         dev_err(dev, "Invalid dsi-lanes: %d\n", num_lanes);
@@ -255,6 +270,9 @@ static int sn65dsi83_parse_dt(struct device_node *np,
     sn65dsi83->brg->width_mm = width;
     sn65dsi83->brg->height_mm = height;
 
+    sn65dsi83->brg->dual_channels = dual_channels;
+    sn65dsi83->brg->pattern = pattern;
+
     /* Read default timing if there is not device tree node for */
     if ((of_get_videomode(np, &sn65dsi83->brg->vm, 0)) < 0)
 	{
@@ -351,7 +369,7 @@ static int sn65dsi83_attach_dsi(struct sn65dsi83 *sn65dsi83)
 //    dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_HSE |
 //               MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_VIDEO_BURST;
 
-  dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_HSE;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_LPM | MIPI_DSI_MODE_VIDEO_BURST;
 //	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_SYNC_PULSE |
 //			  MIPI_DSI_MODE_EOT_PACKET | MIPI_DSI_MODE_VIDEO_HSE;
 
-- 
2.7.4

